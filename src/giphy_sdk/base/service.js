/**
 * Method responsible for adding parameters (queryString) to a url (url)
 * @param {string} url Url to add parameters
 * @param {object} queryString Objet(key: parameter name, value: parameter value)
 *  that you wish to send to the request
 * @returns {string} The complete url (with queryString included)
 */
const appendQueryString  = (url, queryString = {}) => {
  const keysQueryString = Object.keys(queryString);
  const hasValues = Object.values(queryString).every((val) => val !== null && val !== '');
  // If the querystring is  not empty
  if (keysQueryString.length > 0 && hasValues) {
    // If the url contains the '?' char, that means that the url has parameter
    const hasParameters = url.indexOf('?') !== -1;
    
    // If the url has any parameter too, add '&' if dont add '?' to url
    let withQryString =
      url +
        (hasParameters ? '&' : '?');

    // Add each parameter received on the queryString object to url
    withQryString = keysQueryString.reduce((prev, paramKey) => {
      return `${prev}${paramKey}=${queryString[paramKey]}&`;
    }, withQryString)
      // Remove last char "&"
      .slice(0, -1);

    return withQryString;
  } else {
    return url;
  }
};

  /**
   * Method responsible of concatenate a baseUrl (urlBase) with the sub Url (subUri)
   * 
   * @param  {string} baseUrl Base url
   * @param  {string} subUri Sub url to add it to the base url
   * @param  {object} queryString 
   *  The Filters that will be added to the base url ({baseUrl}/{subUri}?filter=1&filter2=hello)
   * @return {string} The complete Url
   */
  const createUrl  = (baseUrl, subUri, queryString = {}) => {
    let toUrl =
      baseUrl +
        (subUri.startsWith('/') || baseUrl.endsWith('/') ? '' : '/') + subUri;
    if (queryString.id) {
      toUrl = `${toUrl}/${queryString.id}/`;
      delete(queryString.id);
    }
    toUrl = appendQueryString(toUrl, queryString);
    return toUrl;
  }

/**
 * Base class for the services created to connect with GIPHY Api
 **/
class Service {
  constructor () {
    super();
    this.getData = this.getData.bind(this);

    this.url = '';
  }

  /**
   * @private _createUrl - Method responsible of concatenate a baseUrl (urlBase) with 
   * the sub Url (subUri)
   * 
   * @param  {string} subUri Sub url to add it to the base url
   * @param  {object} queryString 
   *  The Filters that will be added to the base url ({baseUrl}/{subUri}?filter=1&filter2=hello)
   * @return {string} The complete Url
   */
  _createUrl (subUri, queryString = {}) {
    return createUrl(this.url.href, subUri, queryString);
  }

  /**
   * @private _onLoadRequest - Event received on (new XMLHttpRequest()).onload
   *
   * @param  {object} eventOnLoadXMLHttpRequest Event received on (new XMLHttpRequest()).onload
   * @return {object} JSON object or array, downloaded from the onload event
   */
  _onLoadRequest (eventOnLoadXMLHttpRequest) {
    const {target} = eventOnLoadXMLHttpRequest;
    if (target.status >= 200 && target.status < 400) {
      var data = JSON.parse(target.response);
      return data;
    } else {
      throw new Error('Response received and there was an error');
    }
  }

  /**
   * @private _onErrorRequest - Method to process errors
   *
   * @param  {type} eventOnErrorXMLHttpRequest Event received on (new XMLHttpRequest()).onerror
   * @return {Error}  Error generated by this method
   */
  _onErrorRequest (eventOnErrorXMLHttpRequest) {
    return new Error('Request error');
  }

  /**
   * Method responsible of get data with the HTTP request with the GET method
   *
   * @param  {string} subUri
   *  Sub uri to add to the the base Url
   * @param {object} options Options to getData:
   *  queryString: Object with the parameters that will be added to the request 
   *    ex. { 'byString': 'whatever you want' }
   * @return {Promise<object|array>}
   *  Promise with the http request:
   *    The resolve: receive the json data from the url requested ({}, or [])
   *    The reject: receive Error with the info
   */
  getData (subUri, options = { queryString: {} }) {
    const self = this;
    const { queryString } = options;

    return new Promise((resolve, reject) => {
      const toUrl = self._createUrl(subUri, queryString);
      const request = new XMLHttpRequest();

      request.open('GET', toUrl);

      request.onload = (e) => {
        try {
          const data = self._onLoadRequest(e);
          resolve(data);
        } catch (err) {
          const error = new Error(`${err.message}: getData Failed failed on Service class`);
          error.stack = err.stack;
          reject(error);
        }
      };

      request.onerror = (e) => {
        const err = self._onErrorRequest(e);
        const error = new Error(`${err.message}: getData (url) Failed`);
        error.stack = err.stack;
        reject(error);
      };

      request.send();
    });
  }
}


export default Service;
